{"title":"STL选讲","slug":"STL选讲","date":"2021-09-04T10:09:59.107Z","updated":"2021-09-04T10:09:59.107Z","comments":true,"path":"api/articles/STL选讲.json","excerpt":"STL是什么STL是建立在模板函数和类模板基础之上的功能强大的库，包括：<br>    —— 1）常用算法函数（如统计、排序、查找等）<br>    —— 2）容器​    容器：存放数据的数据结构，例如数组、队列、栈、链表、树、图等，分为：<br>​        ——顺序容器：是指数据逻辑上、物理上都是按顺序存放的。 ​                常见的有：vector、queue、stack、deque。 ​        ——关联容器：存放的数据逻辑上有一定关联，但不一定是按顺序存放的 ​                常见的有set、multiset、map、multimap​    迭代器(iterator):类似于C++中的指针，你可以把它看作是容器的数据存取员，通过它可以依次存取容器中的元素。不同的容器需要不同的迭代器，但这些迭代器的使用方法却类似。","covers":null,"content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css\"><h3 id=\"STL是什么\"><a href=\"#STL是什么\" class=\"headerlink\" title=\"STL是什么\"></a>STL是什么</h3><p>STL是建立在模板函数和类模板基础之上的功能强大的库，包括：<br>    —— 1）常用算法函数（如统计、排序、查找等）<br>    —— 2）容器</p>\n<p>​    容器：存放数据的数据结构，例如数组、队列、栈、链表、树、图等，分为：<br>​        ——顺序容器：是指数据逻辑上、物理上都是按顺序存放的。 </p>\n<p>​                常见的有：vector、queue、stack、deque。 </p>\n<p>​        ——关联容器：存放的数据逻辑上有一定关联，但不一定是按顺序存放的 </p>\n<p>​                常见的有set、multiset、map、multimap</p>\n<p>​    迭代器(iterator):类似于C++中的指针，你可以把它看作是容器的数据存取员，通过它可以依次存取容器中的元素。不同的容器需要不同的迭代器，但这些迭代器的使用方法却类似。</p>\n<span id=\"more\"></span>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><h4 id=\"定义及简单变量类型数组排序\"><a href=\"#定义及简单变量类型数组排序\" class=\"headerlink\" title=\"定义及简单变量类型数组排序\"></a>定义及简单变量类型数组排序</h4><p>​    我们学过选择排序、冒泡排序、插入排序等各种排序算法，其实STL给我们提 供了排序函数sort，我们可以直接使用它！例如： </p>\n<pre><code class=\"lang-c++\">int a[100010],n; \ncin&gt;&gt;n; \nfor(int i=0;i&lt;n;i++)\n    cin&gt;&gt;a[i]; //需要排序，可以直接调用STL排序函数 \nsort(a,a+n); //将a数组下标[0,n)区间元素（左闭右开）排序，默认按从小到大顺序排列 \nfor(int i=0;i&lt;n;i++)\n    cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n</code></pre>\n<p>​    sort是STL里的一个排序函数，包含在<algorithm>头文件中，它是利用快速 排序算法实现并进行优化的，具有非常高的效率，其时间复杂度为O(nlogn) </p>\n<pre><code class=\"lang-c++\">sort(a,a+n,greater&lt;int&gt;()); \n//greater&lt;int&gt;()表示C++内置类型从大到小排序，尖括号里面int表示数组元素的数据类型\n//如果是其他类型，就写相应的变量类型,如double等\n//相对应还有less&lt;int&gt;()表示从小到大排序，这是系统默认的，可以省略。同样也可以使用函数来代替\n//例如:\nbool cmp(int a,int b)\n&#123;\n    return a &gt; b;//降序排列\n&#125;\nsort(x,x+n,cmp);\n</code></pre>\n<h4 id=\"sort对结构体排序\"><a href=\"#sort对结构体排序\" class=\"headerlink\" title=\"sort对结构体排序\"></a>sort对结构体排序</h4><p>​    sort除了对简单变量类型数组进行排序外，还可以对自定义的结构体数组进行排序。 </p>\n<p>​    只是要提供结构体比较大小的函数，因为C++不知道自定义的结构体变量 谁大谁小。我们可以通过在结构体内添加比较大小的函数来实现！</p>\n<h5 id=\"结构体成员函数介绍\"><a href=\"#结构体成员函数介绍\" class=\"headerlink\" title=\"结构体成员函数介绍\"></a>结构体成员函数介绍</h5><p>​    结构体内其实除了定义“成员变量” ，将这些成员变量组合在一起之外，它的功 能非常强大，还可以在结构体内定义函数，我们称其为“成员函数”。</p>\n<p>​    成员函数主要完成跟结构体相关的功能，它可以直接调用结构体的成员变量，还 可以通过形参接受调用者传递进来的参数。例如：</p>\n<pre><code class=\"lang-c++\">struct Student&#123; \n    string Name; \n    int Chinese,Math,English,sum; \n    int GetSum()&#123; \n        sum=Chinese+Math+English; \n        return sum; \n    &#125; \n&#125;\nint main()&#123; \n    Student stu; \n    stu.Chinese=120; \n    stu.Math=130; \n    stu.English=90; \n    cout&lt;&lt;stu.GetSum()&lt;&lt;endl; \n&#125;\n&gt;&gt;输出 340\n</code></pre>\n<h5 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h5><p>​    为了完成结构体比较大小的功能，我们可以在结构体里面定义一个比较大小的函数 。因为STL提供的算法函数、容器一般是调用小于运算符比较大小，所以我们这里重载 小于运算符，这样结构体就可以直接用小于运算符比较大小了。例如：</p>\n<pre><code class=\"lang-c++\">struct node&#123; \n    int x,y; \n    bool operator&lt;(node const &amp;a)const &#123; //重载&lt;运算符 \n        return x&lt;a.x; \n    &#125; \n&#125;;\n//operator    相当于函数名，固定格式，照样子写即可\n//const &amp;a    表示形参是常变量，函数中不允许修改形参\n//后一个const    表示该函数是常函数，不允 许修改结构体成员变量的值\n</code></pre>\n<h5 id=\"运算符重载函数的调用\"><a href=\"#运算符重载函数的调用\" class=\"headerlink\" title=\"运算符重载函数的调用\"></a>运算符重载函数的调用</h5><p>例如：</p>\n<pre><code class=\"lang-c++\">...//结构体与上文一样\n\nnode a,b; \na.x=12;\na.y=3; \nb.x=8;\nb.y=9; \nif(a&lt;b)\n    cout&lt;&lt;&quot;a&lt;b&quot;; \nelse \n    cout&lt;&lt;&quot;a&gt;=b&quot;; \n&gt;&gt;输出 &quot;a&gt;=b&quot;\n</code></pre>\n<p>​    重载运算符我们可以把它看作是一类特殊的成员函数,a&lt;b本质是a.operator&lt;(b)，这里小于运算符是a的成员函数。所以重载运算符时传递的参数 只有一个。 </p>\n<pre><code class=\"lang-c++\">struct node&#123; \n    int x,y; \n    bool operator&lt;(node const &amp;a)const &#123; \n        return x&lt;a.x;//从小到大排\n    &#125; \n&#125;;\nnode p;\nsort(p,p+n);\n\n//同样也可以写函数排序\n\nbool cmp(node a,node b)\n&#123;\n    return a.x &lt; b.x;\n&#125;\nsort(p, p+n, cmp);\n</code></pre>\n<p>补充: 初始化成员变量</p>\n<pre><code class=\"lang-c++\">struct node&#123; \n    double x,y; \n    node(int _x=0,int _y=0):x(_x),y(_y)&#123;&#125; //构造函数，完成成员变量初始化 \n&#125;\n</code></pre>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><h4 id=\"vector的定义\"><a href=\"#vector的定义\" class=\"headerlink\" title=\"vector的定义\"></a>vector的定义</h4><p>​    vector是一种顺序容器，可以把它看作数组，是长度可变的动态数组。它的 储存空间根据存入数据多少自动分配，包含在<vector>头文件中。</p>\n<p>例如：</p>\n<pre><code class=\"lang-c++\">vector&lt;double&gt;a; vector&lt;string&gt;a; vector&lt;Node&gt;a;//Node为自定义的结构体 \n//定义时初始化： \n    vector&lt;int&gt;a(10);//定义初始大小为10个元素的vector，初始值为0 \n    vector&lt;int&gt;a(10,2);//定义时给定大小为10，每个元素初始化为2 \n//定义时用数组初始化： \n    int b[10]=&#123;1,2,3,4,5,6,9,10,12,32&#125;;         \n    vector&lt;int&gt;a(b+1,b+8);//用数组初始化，参数为迭代器，数组元素就是其地址 \n//vector数组： \n    vector&lt;int&gt;a[100];//vector数组，相当于二维数组 \n//特别注意：\n    vector&lt;int&gt;a(10)和vector&lt;int&gt;a[10]的区别\n</code></pre>\n<h4 id=\"vector的引用\"><a href=\"#vector的引用\" class=\"headerlink\" title=\"vector的引用\"></a>vector的引用</h4><h5 id=\"下标-访问\"><a href=\"#下标-访问\" class=\"headerlink\" title=\"下标[]访问\"></a>下标[]访问</h5><p>略</p>\n<h5 id=\"迭代器访问\"><a href=\"#迭代器访问\" class=\"headerlink\" title=\"迭代器访问\"></a>迭代器访问</h5><pre><code class=\"lang-c++\">vector&lt;int&gt; ::iterator it;  //定义一个可以访问整型的vector的迭代器。 \nvector&lt;int&gt;a; \n............................. \nfor( it=a.begin(); it!=a.end();  it++ )         cout&lt;&lt; *it &lt;&lt;&quot; &quot;;\n</code></pre>\n<p>​    a.begin()返回指向第一个元素的迭代器；a.end()返回指向最后一个元素 下一个元素位置的迭代器（左闭右开）；<br>​    it!=a.end(); 为结束条件，迭代器一般不比较大小，关联容器的迭代器不 能比较大小，只能判断是否相等；迭代器相当于指针，对于简单变量类型 *it就是 迭代器指向的数据元素的值。</p>\n<h4 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><ol>\n<li>push_back()   在vector的最后添加一个数据元素，复杂度O(1)</li>\n<li>pop_back()   删除最后一个数据元素.复杂度O(1) </li>\n<li>begin ()     返回指向容器第一个元素的迭代器 .例如：it=a.begin();</li>\n<li>end ()    返回指向容器尾端的迭代器.例如：it=a.end();</li>\n<li>size ()     返回vector中数据元素的个数, 复杂度O(1).<br> 例如：for(int i=0; i&lt;a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;” “;</li>\n<li>resize (n)   重设容器数据元素为n个，它改变size()的返回值.如果n大于当前元素个数，则新增元素用默认值初始化，已有的元素不受影响. 如果n比当前数据元素个数小，则多余的舍弃，仅改变size()返回值</li>\n<li>erase    删除;可以删除单个数据元素，也可以删除一个左闭右开区间内的元素<br>例如：c.erase (pos);     //删除迭代器pos指向位置的元素 c.erase(bg,ed); // 删除迭代器[bg,ed)区间的数据 </li>\n<li>clear ()         清空当前的vector，将size()归零，复杂度O(1).</li>\n<li>rbegin()       返回指向最后一个元素的迭代器，用于逆向访问容器，这时要定义逆向迭代器，例如：vector<int>::reverse_iterator it;</li>\n<li>rend()          返回指向第一个元素前一个位置的迭代器，逆向访问的结束位置</li>\n<li>empty()     判断容器是否为空,若为空返回true，否则返回false</li>\n<li>insert ()     插入一个元素。 vector采用分块储存技术，时间复杂度O(log(size())<br>例如：c.insert(pos,elem); // 在迭代器pos指向元素前面插入elem.<br>c.insert(pos,ncount,elem);//在迭代器pos前插入ncount个elem<br>c.insert(pos,first,end);//在迭代器pos前插入区间[first,end)的元素，first和end也是迭代器，表示的区间是左闭右开。</li>\n</ol>\n","more":"<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><h4 id=\"定义及简单变量类型数组排序\"><a href=\"#定义及简单变量类型数组排序\" class=\"headerlink\" title=\"定义及简单变量类型数组排序\"></a>定义及简单变量类型数组排序</h4><p>​    我们学过选择排序、冒泡排序、插入排序等各种排序算法，其实STL给我们提 供了排序函数sort，我们可以直接使用它！例如： </p>\n<pre><code class=\"lang-c++\">int a[100010],n; \ncin&gt;&gt;n; \nfor(int i=0;i&lt;n;i++)\n    cin&gt;&gt;a[i]; //需要排序，可以直接调用STL排序函数 \nsort(a,a+n); //将a数组下标[0,n)区间元素（左闭右开）排序，默认按从小到大顺序排列 \nfor(int i=0;i&lt;n;i++)\n    cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n</code></pre>\n<p>​    sort是STL里的一个排序函数，包含在<algorithm>头文件中，它是利用快速 排序算法实现并进行优化的，具有非常高的效率，其时间复杂度为O(nlogn) </p>\n<pre><code class=\"lang-c++\">sort(a,a+n,greater&lt;int&gt;()); \n//greater&lt;int&gt;()表示C++内置类型从大到小排序，尖括号里面int表示数组元素的数据类型\n//如果是其他类型，就写相应的变量类型,如double等\n//相对应还有less&lt;int&gt;()表示从小到大排序，这是系统默认的，可以省略。同样也可以使用函数来代替\n//例如:\nbool cmp(int a,int b)\n&#123;\n    return a &gt; b;//降序排列\n&#125;\nsort(x,x+n,cmp);\n</code></pre>\n<h4 id=\"sort对结构体排序\"><a href=\"#sort对结构体排序\" class=\"headerlink\" title=\"sort对结构体排序\"></a>sort对结构体排序</h4><p>​    sort除了对简单变量类型数组进行排序外，还可以对自定义的结构体数组进行排序。 </p>\n<p>​    只是要提供结构体比较大小的函数，因为C++不知道自定义的结构体变量 谁大谁小。我们可以通过在结构体内添加比较大小的函数来实现！</p>\n<h5 id=\"结构体成员函数介绍\"><a href=\"#结构体成员函数介绍\" class=\"headerlink\" title=\"结构体成员函数介绍\"></a>结构体成员函数介绍</h5><p>​    结构体内其实除了定义“成员变量” ，将这些成员变量组合在一起之外，它的功 能非常强大，还可以在结构体内定义函数，我们称其为“成员函数”。</p>\n<p>​    成员函数主要完成跟结构体相关的功能，它可以直接调用结构体的成员变量，还 可以通过形参接受调用者传递进来的参数。例如：</p>\n<pre><code class=\"lang-c++\">struct Student&#123; \n    string Name; \n    int Chinese,Math,English,sum; \n    int GetSum()&#123; \n        sum=Chinese+Math+English; \n        return sum; \n    &#125; \n&#125;\nint main()&#123; \n    Student stu; \n    stu.Chinese=120; \n    stu.Math=130; \n    stu.English=90; \n    cout&lt;&lt;stu.GetSum()&lt;&lt;endl; \n&#125;\n&gt;&gt;输出 340\n</code></pre>\n<h5 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h5><p>​    为了完成结构体比较大小的功能，我们可以在结构体里面定义一个比较大小的函数 。因为STL提供的算法函数、容器一般是调用小于运算符比较大小，所以我们这里重载 小于运算符，这样结构体就可以直接用小于运算符比较大小了。例如：</p>\n<pre><code class=\"lang-c++\">struct node&#123; \n    int x,y; \n    bool operator&lt;(node const &amp;a)const &#123; //重载&lt;运算符 \n        return x&lt;a.x; \n    &#125; \n&#125;;\n//operator    相当于函数名，固定格式，照样子写即可\n//const &amp;a    表示形参是常变量，函数中不允许修改形参\n//后一个const    表示该函数是常函数，不允 许修改结构体成员变量的值\n</code></pre>\n<h5 id=\"运算符重载函数的调用\"><a href=\"#运算符重载函数的调用\" class=\"headerlink\" title=\"运算符重载函数的调用\"></a>运算符重载函数的调用</h5><p>例如：</p>\n<pre><code class=\"lang-c++\">...//结构体与上文一样\n\nnode a,b; \na.x=12;\na.y=3; \nb.x=8;\nb.y=9; \nif(a&lt;b)\n    cout&lt;&lt;&quot;a&lt;b&quot;; \nelse \n    cout&lt;&lt;&quot;a&gt;=b&quot;; \n&gt;&gt;输出 &quot;a&gt;=b&quot;\n</code></pre>\n<p>​    重载运算符我们可以把它看作是一类特殊的成员函数,a&lt;b本质是a.operator&lt;(b)，这里小于运算符是a的成员函数。所以重载运算符时传递的参数 只有一个。 </p>\n<pre><code class=\"lang-c++\">struct node&#123; \n    int x,y; \n    bool operator&lt;(node const &amp;a)const &#123; \n        return x&lt;a.x;//从小到大排\n    &#125; \n&#125;;\nnode p;\nsort(p,p+n);\n\n//同样也可以写函数排序\n\nbool cmp(node a,node b)\n&#123;\n    return a.x &lt; b.x;\n&#125;\nsort(p, p+n, cmp);\n</code></pre>\n<p>补充: 初始化成员变量</p>\n<pre><code class=\"lang-c++\">struct node&#123; \n    double x,y; \n    node(int _x=0,int _y=0):x(_x),y(_y)&#123;&#125; //构造函数，完成成员变量初始化 \n&#125;\n</code></pre>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><h4 id=\"vector的定义\"><a href=\"#vector的定义\" class=\"headerlink\" title=\"vector的定义\"></a>vector的定义</h4><p>​    vector是一种顺序容器，可以把它看作数组，是长度可变的动态数组。它的 储存空间根据存入数据多少自动分配，包含在<vector>头文件中。</p>\n<p>例如：</p>\n<pre><code class=\"lang-c++\">vector&lt;double&gt;a; vector&lt;string&gt;a; vector&lt;Node&gt;a;//Node为自定义的结构体 \n//定义时初始化： \n    vector&lt;int&gt;a(10);//定义初始大小为10个元素的vector，初始值为0 \n    vector&lt;int&gt;a(10,2);//定义时给定大小为10，每个元素初始化为2 \n//定义时用数组初始化： \n    int b[10]=&#123;1,2,3,4,5,6,9,10,12,32&#125;;         \n    vector&lt;int&gt;a(b+1,b+8);//用数组初始化，参数为迭代器，数组元素就是其地址 \n//vector数组： \n    vector&lt;int&gt;a[100];//vector数组，相当于二维数组 \n//特别注意：\n    vector&lt;int&gt;a(10)和vector&lt;int&gt;a[10]的区别\n</code></pre>\n<h4 id=\"vector的引用\"><a href=\"#vector的引用\" class=\"headerlink\" title=\"vector的引用\"></a>vector的引用</h4><h5 id=\"下标-访问\"><a href=\"#下标-访问\" class=\"headerlink\" title=\"下标[]访问\"></a>下标[]访问</h5><p>略</p>\n<h5 id=\"迭代器访问\"><a href=\"#迭代器访问\" class=\"headerlink\" title=\"迭代器访问\"></a>迭代器访问</h5><pre><code class=\"lang-c++\">vector&lt;int&gt; ::iterator it;  //定义一个可以访问整型的vector的迭代器。 \nvector&lt;int&gt;a; \n............................. \nfor( it=a.begin(); it!=a.end();  it++ )         cout&lt;&lt; *it &lt;&lt;&quot; &quot;;\n</code></pre>\n<p>​    a.begin()返回指向第一个元素的迭代器；a.end()返回指向最后一个元素 下一个元素位置的迭代器（左闭右开）；<br>​    it!=a.end(); 为结束条件，迭代器一般不比较大小，关联容器的迭代器不 能比较大小，只能判断是否相等；迭代器相当于指针，对于简单变量类型 *it就是 迭代器指向的数据元素的值。</p>\n<h4 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><ol>\n<li>push_back()   在vector的最后添加一个数据元素，复杂度O(1)</li>\n<li>pop_back()   删除最后一个数据元素.复杂度O(1) </li>\n<li>begin ()     返回指向容器第一个元素的迭代器 .例如：it=a.begin();</li>\n<li>end ()    返回指向容器尾端的迭代器.例如：it=a.end();</li>\n<li>size ()     返回vector中数据元素的个数, 复杂度O(1).<br> 例如：for(int i=0; i&lt;a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;” “;</li>\n<li>resize (n)   重设容器数据元素为n个，它改变size()的返回值.如果n大于当前元素个数，则新增元素用默认值初始化，已有的元素不受影响. 如果n比当前数据元素个数小，则多余的舍弃，仅改变size()返回值</li>\n<li>erase    删除;可以删除单个数据元素，也可以删除一个左闭右开区间内的元素<br>例如：c.erase (pos);     //删除迭代器pos指向位置的元素 c.erase(bg,ed); // 删除迭代器[bg,ed)区间的数据 </li>\n<li>clear ()         清空当前的vector，将size()归零，复杂度O(1).</li>\n<li>rbegin()       返回指向最后一个元素的迭代器，用于逆向访问容器，这时要定义逆向迭代器，例如：vector<int>::reverse_iterator it;</li>\n<li>rend()          返回指向第一个元素前一个位置的迭代器，逆向访问的结束位置</li>\n<li>empty()     判断容器是否为空,若为空返回true，否则返回false</li>\n<li>insert ()     插入一个元素。 vector采用分块储存技术，时间复杂度O(log(size())<br>例如：c.insert(pos,elem); // 在迭代器pos指向元素前面插入elem.<br>c.insert(pos,ncount,elem);//在迭代器pos前插入ncount个elem<br>c.insert(pos,first,end);//在迭代器pos前插入区间[first,end)的元素，first和end也是迭代器，表示的区间是左闭右开。</li>\n</ol>","categories":[{"name":"C++","path":"api/categories/C++.json"}],"tags":[{"name":"STL","path":"api/tags/STL.json"}]}